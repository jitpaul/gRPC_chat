// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chat.proto

#ifndef PROTOBUF_chat_2eproto__INCLUDED
#define PROTOBUF_chat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_chat_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsStreamRequestImpl();
void InitDefaultsStreamRequest();
void InitDefaultsStreamResponseImpl();
void InitDefaultsStreamResponse();
void InitDefaultsStartSessionImpl();
void InitDefaultsStartSession();
void InitDefaultsJoinSessionImpl();
void InitDefaultsJoinSession();
void InitDefaultsMessageImpl();
void InitDefaultsMessage();
void InitDefaultsQuitSessionImpl();
void InitDefaultsQuitSession();
void InitDefaultsLoginImpl();
void InitDefaultsLogin();
void InitDefaultsLogoutImpl();
void InitDefaultsLogout();
void InitDefaultsStartSessionResponseImpl();
void InitDefaultsStartSessionResponse();
void InitDefaultsJoinSessionResponseImpl();
void InitDefaultsJoinSessionResponse();
inline void InitDefaults() {
  InitDefaultsStreamRequest();
  InitDefaultsStreamResponse();
  InitDefaultsStartSession();
  InitDefaultsJoinSession();
  InitDefaultsMessage();
  InitDefaultsQuitSession();
  InitDefaultsLogin();
  InitDefaultsLogout();
  InitDefaultsStartSessionResponse();
  InitDefaultsJoinSessionResponse();
}
}  // namespace protobuf_chat_2eproto
namespace chat {
class JoinSession;
class JoinSessionDefaultTypeInternal;
extern JoinSessionDefaultTypeInternal _JoinSession_default_instance_;
class JoinSessionResponse;
class JoinSessionResponseDefaultTypeInternal;
extern JoinSessionResponseDefaultTypeInternal _JoinSessionResponse_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class Logout;
class LogoutDefaultTypeInternal;
extern LogoutDefaultTypeInternal _Logout_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class QuitSession;
class QuitSessionDefaultTypeInternal;
extern QuitSessionDefaultTypeInternal _QuitSession_default_instance_;
class StartSession;
class StartSessionDefaultTypeInternal;
extern StartSessionDefaultTypeInternal _StartSession_default_instance_;
class StartSessionResponse;
class StartSessionResponseDefaultTypeInternal;
extern StartSessionResponseDefaultTypeInternal _StartSessionResponse_default_instance_;
class StreamRequest;
class StreamRequestDefaultTypeInternal;
extern StreamRequestDefaultTypeInternal _StreamRequest_default_instance_;
class StreamResponse;
class StreamResponseDefaultTypeInternal;
extern StreamResponseDefaultTypeInternal _StreamResponse_default_instance_;
}  // namespace chat
namespace chat {

// ===================================================================

class StreamRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.StreamRequest) */ {
 public:
  StreamRequest();
  virtual ~StreamRequest();

  StreamRequest(const StreamRequest& from);

  inline StreamRequest& operator=(const StreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamRequest(StreamRequest&& from) noexcept
    : StreamRequest() {
    *this = ::std::move(from);
  }

  inline StreamRequest& operator=(StreamRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamRequest& default_instance();

  enum RequestEventCase {
    kStartSessionRequest = 1,
    kJoinSessionRequest = 2,
    kMessageRequest = 3,
    kQuitSessionRequest = 4,
    REQUESTEVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamRequest* internal_default_instance() {
    return reinterpret_cast<const StreamRequest*>(
               &_StreamRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(StreamRequest* other);
  friend void swap(StreamRequest& a, StreamRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  StreamRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StreamRequest& from);
  void MergeFrom(const StreamRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StreamRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chat.StartSession startSession_request = 1;
  bool has_startsession_request() const;
  void clear_startsession_request();
  static const int kStartSessionRequestFieldNumber = 1;
  const ::chat::StartSession& startsession_request() const;
  ::chat::StartSession* release_startsession_request();
  ::chat::StartSession* mutable_startsession_request();
  void set_allocated_startsession_request(::chat::StartSession* startsession_request);

  // .chat.JoinSession joinSession_request = 2;
  bool has_joinsession_request() const;
  void clear_joinsession_request();
  static const int kJoinSessionRequestFieldNumber = 2;
  const ::chat::JoinSession& joinsession_request() const;
  ::chat::JoinSession* release_joinsession_request();
  ::chat::JoinSession* mutable_joinsession_request();
  void set_allocated_joinsession_request(::chat::JoinSession* joinsession_request);

  // .chat.Message message_request = 3;
  bool has_message_request() const;
  void clear_message_request();
  static const int kMessageRequestFieldNumber = 3;
  const ::chat::Message& message_request() const;
  ::chat::Message* release_message_request();
  ::chat::Message* mutable_message_request();
  void set_allocated_message_request(::chat::Message* message_request);

  // .chat.QuitSession quitSession_request = 4;
  bool has_quitsession_request() const;
  void clear_quitsession_request();
  static const int kQuitSessionRequestFieldNumber = 4;
  const ::chat::QuitSession& quitsession_request() const;
  ::chat::QuitSession* release_quitsession_request();
  ::chat::QuitSession* mutable_quitsession_request();
  void set_allocated_quitsession_request(::chat::QuitSession* quitsession_request);

  RequestEventCase RequestEvent_case() const;
  // @@protoc_insertion_point(class_scope:chat.StreamRequest)
 private:
  void set_has_startsession_request();
  void set_has_joinsession_request();
  void set_has_message_request();
  void set_has_quitsession_request();

  inline bool has_RequestEvent() const;
  void clear_RequestEvent();
  inline void clear_has_RequestEvent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RequestEventUnion {
    RequestEventUnion() {}
    ::chat::StartSession* startsession_request_;
    ::chat::JoinSession* joinsession_request_;
    ::chat::Message* message_request_;
    ::chat::QuitSession* quitsession_request_;
  } RequestEvent_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsStreamRequestImpl();
};
// -------------------------------------------------------------------

class StreamResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.StreamResponse) */ {
 public:
  StreamResponse();
  virtual ~StreamResponse();

  StreamResponse(const StreamResponse& from);

  inline StreamResponse& operator=(const StreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamResponse(StreamResponse&& from) noexcept
    : StreamResponse() {
    *this = ::std::move(from);
  }

  inline StreamResponse& operator=(StreamResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamResponse& default_instance();

  enum ResponseEventCase {
    kLoginResponse = 1,
    kLogoutResponse = 2,
    kMessageResponse = 3,
    kStartsessionResponse = 4,
    kJoinsessionResponse = 5,
    RESPONSEEVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamResponse* internal_default_instance() {
    return reinterpret_cast<const StreamResponse*>(
               &_StreamResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(StreamResponse* other);
  friend void swap(StreamResponse& a, StreamResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  StreamResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StreamResponse& from);
  void MergeFrom(const StreamResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StreamResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chat.Login login_response = 1;
  bool has_login_response() const;
  void clear_login_response();
  static const int kLoginResponseFieldNumber = 1;
  const ::chat::Login& login_response() const;
  ::chat::Login* release_login_response();
  ::chat::Login* mutable_login_response();
  void set_allocated_login_response(::chat::Login* login_response);

  // .chat.Logout logout_response = 2;
  bool has_logout_response() const;
  void clear_logout_response();
  static const int kLogoutResponseFieldNumber = 2;
  const ::chat::Logout& logout_response() const;
  ::chat::Logout* release_logout_response();
  ::chat::Logout* mutable_logout_response();
  void set_allocated_logout_response(::chat::Logout* logout_response);

  // .chat.Message message_response = 3;
  bool has_message_response() const;
  void clear_message_response();
  static const int kMessageResponseFieldNumber = 3;
  const ::chat::Message& message_response() const;
  ::chat::Message* release_message_response();
  ::chat::Message* mutable_message_response();
  void set_allocated_message_response(::chat::Message* message_response);

  // .chat.StartSessionResponse startsession_response = 4;
  bool has_startsession_response() const;
  void clear_startsession_response();
  static const int kStartsessionResponseFieldNumber = 4;
  const ::chat::StartSessionResponse& startsession_response() const;
  ::chat::StartSessionResponse* release_startsession_response();
  ::chat::StartSessionResponse* mutable_startsession_response();
  void set_allocated_startsession_response(::chat::StartSessionResponse* startsession_response);

  // .chat.JoinSessionResponse joinsession_response = 5;
  bool has_joinsession_response() const;
  void clear_joinsession_response();
  static const int kJoinsessionResponseFieldNumber = 5;
  const ::chat::JoinSessionResponse& joinsession_response() const;
  ::chat::JoinSessionResponse* release_joinsession_response();
  ::chat::JoinSessionResponse* mutable_joinsession_response();
  void set_allocated_joinsession_response(::chat::JoinSessionResponse* joinsession_response);

  ResponseEventCase ResponseEvent_case() const;
  // @@protoc_insertion_point(class_scope:chat.StreamResponse)
 private:
  void set_has_login_response();
  void set_has_logout_response();
  void set_has_message_response();
  void set_has_startsession_response();
  void set_has_joinsession_response();

  inline bool has_ResponseEvent() const;
  void clear_ResponseEvent();
  inline void clear_has_ResponseEvent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ResponseEventUnion {
    ResponseEventUnion() {}
    ::chat::Login* login_response_;
    ::chat::Logout* logout_response_;
    ::chat::Message* message_response_;
    ::chat::StartSessionResponse* startsession_response_;
    ::chat::JoinSessionResponse* joinsession_response_;
  } ResponseEvent_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsStreamResponseImpl();
};
// -------------------------------------------------------------------

class StartSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.StartSession) */ {
 public:
  StartSession();
  virtual ~StartSession();

  StartSession(const StartSession& from);

  inline StartSession& operator=(const StartSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartSession(StartSession&& from) noexcept
    : StartSession() {
    *this = ::std::move(from);
  }

  inline StartSession& operator=(StartSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartSession* internal_default_instance() {
    return reinterpret_cast<const StartSession*>(
               &_StartSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(StartSession* other);
  friend void swap(StartSession& a, StartSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartSession* New() const PROTOBUF_FINAL { return New(NULL); }

  StartSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StartSession& from);
  void MergeFrom(const StartSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StartSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:chat.StartSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsStartSessionImpl();
};
// -------------------------------------------------------------------

class JoinSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.JoinSession) */ {
 public:
  JoinSession();
  virtual ~JoinSession();

  JoinSession(const JoinSession& from);

  inline JoinSession& operator=(const JoinSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinSession(JoinSession&& from) noexcept
    : JoinSession() {
    *this = ::std::move(from);
  }

  inline JoinSession& operator=(JoinSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinSession* internal_default_instance() {
    return reinterpret_cast<const JoinSession*>(
               &_JoinSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(JoinSession* other);
  friend void swap(JoinSession& a, JoinSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinSession* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinSession& from);
  void MergeFrom(const JoinSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // @@protoc_insertion_point(class_scope:chat.JoinSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsJoinSessionImpl();
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // string message = 3;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:chat.Message)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsMessageImpl();
};
// -------------------------------------------------------------------

class QuitSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.QuitSession) */ {
 public:
  QuitSession();
  virtual ~QuitSession();

  QuitSession(const QuitSession& from);

  inline QuitSession& operator=(const QuitSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuitSession(QuitSession&& from) noexcept
    : QuitSession() {
    *this = ::std::move(from);
  }

  inline QuitSession& operator=(QuitSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuitSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuitSession* internal_default_instance() {
    return reinterpret_cast<const QuitSession*>(
               &_QuitSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(QuitSession* other);
  friend void swap(QuitSession& a, QuitSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuitSession* New() const PROTOBUF_FINAL { return New(NULL); }

  QuitSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QuitSession& from);
  void MergeFrom(const QuitSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QuitSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // @@protoc_insertion_point(class_scope:chat.QuitSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsQuitSessionImpl();
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Login* other);
  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const PROTOBUF_FINAL { return New(NULL); }

  Login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:chat.Login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsLoginImpl();
};
// -------------------------------------------------------------------

class Logout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.Logout) */ {
 public:
  Logout();
  virtual ~Logout();

  Logout(const Logout& from);

  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Logout(Logout&& from) noexcept
    : Logout() {
    *this = ::std::move(from);
  }

  inline Logout& operator=(Logout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Logout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logout* internal_default_instance() {
    return reinterpret_cast<const Logout*>(
               &_Logout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Logout* other);
  friend void swap(Logout& a, Logout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Logout* New() const PROTOBUF_FINAL { return New(NULL); }

  Logout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Logout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:chat.Logout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsLogoutImpl();
};
// -------------------------------------------------------------------

class StartSessionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.StartSessionResponse) */ {
 public:
  StartSessionResponse();
  virtual ~StartSessionResponse();

  StartSessionResponse(const StartSessionResponse& from);

  inline StartSessionResponse& operator=(const StartSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartSessionResponse(StartSessionResponse&& from) noexcept
    : StartSessionResponse() {
    *this = ::std::move(from);
  }

  inline StartSessionResponse& operator=(StartSessionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartSessionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartSessionResponse* internal_default_instance() {
    return reinterpret_cast<const StartSessionResponse*>(
               &_StartSessionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(StartSessionResponse* other);
  friend void swap(StartSessionResponse& a, StartSessionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartSessionResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  StartSessionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StartSessionResponse& from);
  void MergeFrom(const StartSessionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StartSessionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_id = 1;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // @@protoc_insertion_point(class_scope:chat.StartSessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsStartSessionResponseImpl();
};
// -------------------------------------------------------------------

class JoinSessionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.JoinSessionResponse) */ {
 public:
  JoinSessionResponse();
  virtual ~JoinSessionResponse();

  JoinSessionResponse(const JoinSessionResponse& from);

  inline JoinSessionResponse& operator=(const JoinSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinSessionResponse(JoinSessionResponse&& from) noexcept
    : JoinSessionResponse() {
    *this = ::std::move(from);
  }

  inline JoinSessionResponse& operator=(JoinSessionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinSessionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinSessionResponse* internal_default_instance() {
    return reinterpret_cast<const JoinSessionResponse*>(
               &_JoinSessionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(JoinSessionResponse* other);
  friend void swap(JoinSessionResponse& a, JoinSessionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinSessionResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinSessionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinSessionResponse& from);
  void MergeFrom(const JoinSessionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinSessionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:chat.JoinSessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
  friend void ::protobuf_chat_2eproto::InitDefaultsJoinSessionResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StreamRequest

// .chat.StartSession startSession_request = 1;
inline bool StreamRequest::has_startsession_request() const {
  return RequestEvent_case() == kStartSessionRequest;
}
inline void StreamRequest::set_has_startsession_request() {
  _oneof_case_[0] = kStartSessionRequest;
}
inline void StreamRequest::clear_startsession_request() {
  if (has_startsession_request()) {
    delete RequestEvent_.startsession_request_;
    clear_has_RequestEvent();
  }
}
inline ::chat::StartSession* StreamRequest::release_startsession_request() {
  // @@protoc_insertion_point(field_release:chat.StreamRequest.startSession_request)
  if (has_startsession_request()) {
    clear_has_RequestEvent();
      ::chat::StartSession* temp = RequestEvent_.startsession_request_;
    RequestEvent_.startsession_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::chat::StartSession& StreamRequest::startsession_request() const {
  // @@protoc_insertion_point(field_get:chat.StreamRequest.startSession_request)
  return has_startsession_request()
      ? *RequestEvent_.startsession_request_
      : *reinterpret_cast< ::chat::StartSession*>(&::chat::_StartSession_default_instance_);
}
inline ::chat::StartSession* StreamRequest::mutable_startsession_request() {
  if (!has_startsession_request()) {
    clear_RequestEvent();
    set_has_startsession_request();
    RequestEvent_.startsession_request_ = new ::chat::StartSession;
  }
  // @@protoc_insertion_point(field_mutable:chat.StreamRequest.startSession_request)
  return RequestEvent_.startsession_request_;
}

// .chat.JoinSession joinSession_request = 2;
inline bool StreamRequest::has_joinsession_request() const {
  return RequestEvent_case() == kJoinSessionRequest;
}
inline void StreamRequest::set_has_joinsession_request() {
  _oneof_case_[0] = kJoinSessionRequest;
}
inline void StreamRequest::clear_joinsession_request() {
  if (has_joinsession_request()) {
    delete RequestEvent_.joinsession_request_;
    clear_has_RequestEvent();
  }
}
inline ::chat::JoinSession* StreamRequest::release_joinsession_request() {
  // @@protoc_insertion_point(field_release:chat.StreamRequest.joinSession_request)
  if (has_joinsession_request()) {
    clear_has_RequestEvent();
      ::chat::JoinSession* temp = RequestEvent_.joinsession_request_;
    RequestEvent_.joinsession_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::chat::JoinSession& StreamRequest::joinsession_request() const {
  // @@protoc_insertion_point(field_get:chat.StreamRequest.joinSession_request)
  return has_joinsession_request()
      ? *RequestEvent_.joinsession_request_
      : *reinterpret_cast< ::chat::JoinSession*>(&::chat::_JoinSession_default_instance_);
}
inline ::chat::JoinSession* StreamRequest::mutable_joinsession_request() {
  if (!has_joinsession_request()) {
    clear_RequestEvent();
    set_has_joinsession_request();
    RequestEvent_.joinsession_request_ = new ::chat::JoinSession;
  }
  // @@protoc_insertion_point(field_mutable:chat.StreamRequest.joinSession_request)
  return RequestEvent_.joinsession_request_;
}

// .chat.Message message_request = 3;
inline bool StreamRequest::has_message_request() const {
  return RequestEvent_case() == kMessageRequest;
}
inline void StreamRequest::set_has_message_request() {
  _oneof_case_[0] = kMessageRequest;
}
inline void StreamRequest::clear_message_request() {
  if (has_message_request()) {
    delete RequestEvent_.message_request_;
    clear_has_RequestEvent();
  }
}
inline ::chat::Message* StreamRequest::release_message_request() {
  // @@protoc_insertion_point(field_release:chat.StreamRequest.message_request)
  if (has_message_request()) {
    clear_has_RequestEvent();
      ::chat::Message* temp = RequestEvent_.message_request_;
    RequestEvent_.message_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::chat::Message& StreamRequest::message_request() const {
  // @@protoc_insertion_point(field_get:chat.StreamRequest.message_request)
  return has_message_request()
      ? *RequestEvent_.message_request_
      : *reinterpret_cast< ::chat::Message*>(&::chat::_Message_default_instance_);
}
inline ::chat::Message* StreamRequest::mutable_message_request() {
  if (!has_message_request()) {
    clear_RequestEvent();
    set_has_message_request();
    RequestEvent_.message_request_ = new ::chat::Message;
  }
  // @@protoc_insertion_point(field_mutable:chat.StreamRequest.message_request)
  return RequestEvent_.message_request_;
}

// .chat.QuitSession quitSession_request = 4;
inline bool StreamRequest::has_quitsession_request() const {
  return RequestEvent_case() == kQuitSessionRequest;
}
inline void StreamRequest::set_has_quitsession_request() {
  _oneof_case_[0] = kQuitSessionRequest;
}
inline void StreamRequest::clear_quitsession_request() {
  if (has_quitsession_request()) {
    delete RequestEvent_.quitsession_request_;
    clear_has_RequestEvent();
  }
}
inline ::chat::QuitSession* StreamRequest::release_quitsession_request() {
  // @@protoc_insertion_point(field_release:chat.StreamRequest.quitSession_request)
  if (has_quitsession_request()) {
    clear_has_RequestEvent();
      ::chat::QuitSession* temp = RequestEvent_.quitsession_request_;
    RequestEvent_.quitsession_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::chat::QuitSession& StreamRequest::quitsession_request() const {
  // @@protoc_insertion_point(field_get:chat.StreamRequest.quitSession_request)
  return has_quitsession_request()
      ? *RequestEvent_.quitsession_request_
      : *reinterpret_cast< ::chat::QuitSession*>(&::chat::_QuitSession_default_instance_);
}
inline ::chat::QuitSession* StreamRequest::mutable_quitsession_request() {
  if (!has_quitsession_request()) {
    clear_RequestEvent();
    set_has_quitsession_request();
    RequestEvent_.quitsession_request_ = new ::chat::QuitSession;
  }
  // @@protoc_insertion_point(field_mutable:chat.StreamRequest.quitSession_request)
  return RequestEvent_.quitsession_request_;
}

inline bool StreamRequest::has_RequestEvent() const {
  return RequestEvent_case() != REQUESTEVENT_NOT_SET;
}
inline void StreamRequest::clear_has_RequestEvent() {
  _oneof_case_[0] = REQUESTEVENT_NOT_SET;
}
inline StreamRequest::RequestEventCase StreamRequest::RequestEvent_case() const {
  return StreamRequest::RequestEventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamResponse

// .chat.Login login_response = 1;
inline bool StreamResponse::has_login_response() const {
  return ResponseEvent_case() == kLoginResponse;
}
inline void StreamResponse::set_has_login_response() {
  _oneof_case_[0] = kLoginResponse;
}
inline void StreamResponse::clear_login_response() {
  if (has_login_response()) {
    delete ResponseEvent_.login_response_;
    clear_has_ResponseEvent();
  }
}
inline ::chat::Login* StreamResponse::release_login_response() {
  // @@protoc_insertion_point(field_release:chat.StreamResponse.login_response)
  if (has_login_response()) {
    clear_has_ResponseEvent();
      ::chat::Login* temp = ResponseEvent_.login_response_;
    ResponseEvent_.login_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::chat::Login& StreamResponse::login_response() const {
  // @@protoc_insertion_point(field_get:chat.StreamResponse.login_response)
  return has_login_response()
      ? *ResponseEvent_.login_response_
      : *reinterpret_cast< ::chat::Login*>(&::chat::_Login_default_instance_);
}
inline ::chat::Login* StreamResponse::mutable_login_response() {
  if (!has_login_response()) {
    clear_ResponseEvent();
    set_has_login_response();
    ResponseEvent_.login_response_ = new ::chat::Login;
  }
  // @@protoc_insertion_point(field_mutable:chat.StreamResponse.login_response)
  return ResponseEvent_.login_response_;
}

// .chat.Logout logout_response = 2;
inline bool StreamResponse::has_logout_response() const {
  return ResponseEvent_case() == kLogoutResponse;
}
inline void StreamResponse::set_has_logout_response() {
  _oneof_case_[0] = kLogoutResponse;
}
inline void StreamResponse::clear_logout_response() {
  if (has_logout_response()) {
    delete ResponseEvent_.logout_response_;
    clear_has_ResponseEvent();
  }
}
inline ::chat::Logout* StreamResponse::release_logout_response() {
  // @@protoc_insertion_point(field_release:chat.StreamResponse.logout_response)
  if (has_logout_response()) {
    clear_has_ResponseEvent();
      ::chat::Logout* temp = ResponseEvent_.logout_response_;
    ResponseEvent_.logout_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::chat::Logout& StreamResponse::logout_response() const {
  // @@protoc_insertion_point(field_get:chat.StreamResponse.logout_response)
  return has_logout_response()
      ? *ResponseEvent_.logout_response_
      : *reinterpret_cast< ::chat::Logout*>(&::chat::_Logout_default_instance_);
}
inline ::chat::Logout* StreamResponse::mutable_logout_response() {
  if (!has_logout_response()) {
    clear_ResponseEvent();
    set_has_logout_response();
    ResponseEvent_.logout_response_ = new ::chat::Logout;
  }
  // @@protoc_insertion_point(field_mutable:chat.StreamResponse.logout_response)
  return ResponseEvent_.logout_response_;
}

// .chat.Message message_response = 3;
inline bool StreamResponse::has_message_response() const {
  return ResponseEvent_case() == kMessageResponse;
}
inline void StreamResponse::set_has_message_response() {
  _oneof_case_[0] = kMessageResponse;
}
inline void StreamResponse::clear_message_response() {
  if (has_message_response()) {
    delete ResponseEvent_.message_response_;
    clear_has_ResponseEvent();
  }
}
inline ::chat::Message* StreamResponse::release_message_response() {
  // @@protoc_insertion_point(field_release:chat.StreamResponse.message_response)
  if (has_message_response()) {
    clear_has_ResponseEvent();
      ::chat::Message* temp = ResponseEvent_.message_response_;
    ResponseEvent_.message_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::chat::Message& StreamResponse::message_response() const {
  // @@protoc_insertion_point(field_get:chat.StreamResponse.message_response)
  return has_message_response()
      ? *ResponseEvent_.message_response_
      : *reinterpret_cast< ::chat::Message*>(&::chat::_Message_default_instance_);
}
inline ::chat::Message* StreamResponse::mutable_message_response() {
  if (!has_message_response()) {
    clear_ResponseEvent();
    set_has_message_response();
    ResponseEvent_.message_response_ = new ::chat::Message;
  }
  // @@protoc_insertion_point(field_mutable:chat.StreamResponse.message_response)
  return ResponseEvent_.message_response_;
}

// .chat.StartSessionResponse startsession_response = 4;
inline bool StreamResponse::has_startsession_response() const {
  return ResponseEvent_case() == kStartsessionResponse;
}
inline void StreamResponse::set_has_startsession_response() {
  _oneof_case_[0] = kStartsessionResponse;
}
inline void StreamResponse::clear_startsession_response() {
  if (has_startsession_response()) {
    delete ResponseEvent_.startsession_response_;
    clear_has_ResponseEvent();
  }
}
inline ::chat::StartSessionResponse* StreamResponse::release_startsession_response() {
  // @@protoc_insertion_point(field_release:chat.StreamResponse.startsession_response)
  if (has_startsession_response()) {
    clear_has_ResponseEvent();
      ::chat::StartSessionResponse* temp = ResponseEvent_.startsession_response_;
    ResponseEvent_.startsession_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::chat::StartSessionResponse& StreamResponse::startsession_response() const {
  // @@protoc_insertion_point(field_get:chat.StreamResponse.startsession_response)
  return has_startsession_response()
      ? *ResponseEvent_.startsession_response_
      : *reinterpret_cast< ::chat::StartSessionResponse*>(&::chat::_StartSessionResponse_default_instance_);
}
inline ::chat::StartSessionResponse* StreamResponse::mutable_startsession_response() {
  if (!has_startsession_response()) {
    clear_ResponseEvent();
    set_has_startsession_response();
    ResponseEvent_.startsession_response_ = new ::chat::StartSessionResponse;
  }
  // @@protoc_insertion_point(field_mutable:chat.StreamResponse.startsession_response)
  return ResponseEvent_.startsession_response_;
}

// .chat.JoinSessionResponse joinsession_response = 5;
inline bool StreamResponse::has_joinsession_response() const {
  return ResponseEvent_case() == kJoinsessionResponse;
}
inline void StreamResponse::set_has_joinsession_response() {
  _oneof_case_[0] = kJoinsessionResponse;
}
inline void StreamResponse::clear_joinsession_response() {
  if (has_joinsession_response()) {
    delete ResponseEvent_.joinsession_response_;
    clear_has_ResponseEvent();
  }
}
inline ::chat::JoinSessionResponse* StreamResponse::release_joinsession_response() {
  // @@protoc_insertion_point(field_release:chat.StreamResponse.joinsession_response)
  if (has_joinsession_response()) {
    clear_has_ResponseEvent();
      ::chat::JoinSessionResponse* temp = ResponseEvent_.joinsession_response_;
    ResponseEvent_.joinsession_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::chat::JoinSessionResponse& StreamResponse::joinsession_response() const {
  // @@protoc_insertion_point(field_get:chat.StreamResponse.joinsession_response)
  return has_joinsession_response()
      ? *ResponseEvent_.joinsession_response_
      : *reinterpret_cast< ::chat::JoinSessionResponse*>(&::chat::_JoinSessionResponse_default_instance_);
}
inline ::chat::JoinSessionResponse* StreamResponse::mutable_joinsession_response() {
  if (!has_joinsession_response()) {
    clear_ResponseEvent();
    set_has_joinsession_response();
    ResponseEvent_.joinsession_response_ = new ::chat::JoinSessionResponse;
  }
  // @@protoc_insertion_point(field_mutable:chat.StreamResponse.joinsession_response)
  return ResponseEvent_.joinsession_response_;
}

inline bool StreamResponse::has_ResponseEvent() const {
  return ResponseEvent_case() != RESPONSEEVENT_NOT_SET;
}
inline void StreamResponse::clear_has_ResponseEvent() {
  _oneof_case_[0] = RESPONSEEVENT_NOT_SET;
}
inline StreamResponse::ResponseEventCase StreamResponse::ResponseEvent_case() const {
  return StreamResponse::ResponseEventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StartSession

// string userName = 1;
inline void StartSession::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StartSession::username() const {
  // @@protoc_insertion_point(field_get:chat.StartSession.userName)
  return username_.GetNoArena();
}
inline void StartSession::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.StartSession.userName)
}
#if LANG_CXX11
inline void StartSession::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.StartSession.userName)
}
#endif
inline void StartSession::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.StartSession.userName)
}
inline void StartSession::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.StartSession.userName)
}
inline ::std::string* StartSession::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chat.StartSession.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StartSession::release_username() {
  // @@protoc_insertion_point(field_release:chat.StartSession.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StartSession::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.StartSession.userName)
}

// -------------------------------------------------------------------

// JoinSession

// string userName = 1;
inline void JoinSession::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinSession::username() const {
  // @@protoc_insertion_point(field_get:chat.JoinSession.userName)
  return username_.GetNoArena();
}
inline void JoinSession::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.JoinSession.userName)
}
#if LANG_CXX11
inline void JoinSession::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.JoinSession.userName)
}
#endif
inline void JoinSession::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.JoinSession.userName)
}
inline void JoinSession::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.JoinSession.userName)
}
inline ::std::string* JoinSession::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chat.JoinSession.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinSession::release_username() {
  // @@protoc_insertion_point(field_release:chat.JoinSession.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinSession::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.JoinSession.userName)
}

// string session_id = 2;
inline void JoinSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinSession::session_id() const {
  // @@protoc_insertion_point(field_get:chat.JoinSession.session_id)
  return session_id_.GetNoArena();
}
inline void JoinSession::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.JoinSession.session_id)
}
#if LANG_CXX11
inline void JoinSession::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.JoinSession.session_id)
}
#endif
inline void JoinSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.JoinSession.session_id)
}
inline void JoinSession::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.JoinSession.session_id)
}
inline ::std::string* JoinSession::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:chat.JoinSession.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinSession::release_session_id() {
  // @@protoc_insertion_point(field_release:chat.JoinSession.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinSession::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:chat.JoinSession.session_id)
}

// -------------------------------------------------------------------

// Message

// string userName = 1;
inline void Message::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::username() const {
  // @@protoc_insertion_point(field_get:chat.Message.userName)
  return username_.GetNoArena();
}
inline void Message::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.Message.userName)
}
#if LANG_CXX11
inline void Message::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.Message.userName)
}
#endif
inline void Message::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.Message.userName)
}
inline void Message::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.Message.userName)
}
inline ::std::string* Message::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chat.Message.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_username() {
  // @@protoc_insertion_point(field_release:chat.Message.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.Message.userName)
}

// string session_id = 2;
inline void Message::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::session_id() const {
  // @@protoc_insertion_point(field_get:chat.Message.session_id)
  return session_id_.GetNoArena();
}
inline void Message::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.Message.session_id)
}
#if LANG_CXX11
inline void Message::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.Message.session_id)
}
#endif
inline void Message::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.Message.session_id)
}
inline void Message::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.Message.session_id)
}
inline ::std::string* Message::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:chat.Message.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_session_id() {
  // @@protoc_insertion_point(field_release:chat.Message.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:chat.Message.session_id)
}

// string message = 3;
inline void Message::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::message() const {
  // @@protoc_insertion_point(field_get:chat.Message.message)
  return message_.GetNoArena();
}
inline void Message::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.Message.message)
}
#if LANG_CXX11
inline void Message::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.Message.message)
}
#endif
inline void Message::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.Message.message)
}
inline void Message::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.Message.message)
}
inline ::std::string* Message::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:chat.Message.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_message() {
  // @@protoc_insertion_point(field_release:chat.Message.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.Message.message)
}

// -------------------------------------------------------------------

// QuitSession

// string userName = 1;
inline void QuitSession::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QuitSession::username() const {
  // @@protoc_insertion_point(field_get:chat.QuitSession.userName)
  return username_.GetNoArena();
}
inline void QuitSession::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.QuitSession.userName)
}
#if LANG_CXX11
inline void QuitSession::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.QuitSession.userName)
}
#endif
inline void QuitSession::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.QuitSession.userName)
}
inline void QuitSession::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.QuitSession.userName)
}
inline ::std::string* QuitSession::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chat.QuitSession.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuitSession::release_username() {
  // @@protoc_insertion_point(field_release:chat.QuitSession.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuitSession::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.QuitSession.userName)
}

// string session_id = 2;
inline void QuitSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QuitSession::session_id() const {
  // @@protoc_insertion_point(field_get:chat.QuitSession.session_id)
  return session_id_.GetNoArena();
}
inline void QuitSession::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.QuitSession.session_id)
}
#if LANG_CXX11
inline void QuitSession::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.QuitSession.session_id)
}
#endif
inline void QuitSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.QuitSession.session_id)
}
inline void QuitSession::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.QuitSession.session_id)
}
inline ::std::string* QuitSession::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:chat.QuitSession.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuitSession::release_session_id() {
  // @@protoc_insertion_point(field_release:chat.QuitSession.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuitSession::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:chat.QuitSession.session_id)
}

// -------------------------------------------------------------------

// Login

// string userName = 1;
inline void Login::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::username() const {
  // @@protoc_insertion_point(field_get:chat.Login.userName)
  return username_.GetNoArena();
}
inline void Login::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.Login.userName)
}
#if LANG_CXX11
inline void Login::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.Login.userName)
}
#endif
inline void Login::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.Login.userName)
}
inline void Login::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.Login.userName)
}
inline ::std::string* Login::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chat.Login.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_username() {
  // @@protoc_insertion_point(field_release:chat.Login.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.Login.userName)
}

// -------------------------------------------------------------------

// Logout

// string userName = 1;
inline void Logout::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Logout::username() const {
  // @@protoc_insertion_point(field_get:chat.Logout.userName)
  return username_.GetNoArena();
}
inline void Logout::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.Logout.userName)
}
#if LANG_CXX11
inline void Logout::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.Logout.userName)
}
#endif
inline void Logout::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.Logout.userName)
}
inline void Logout::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.Logout.userName)
}
inline ::std::string* Logout::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chat.Logout.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Logout::release_username() {
  // @@protoc_insertion_point(field_release:chat.Logout.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Logout::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.Logout.userName)
}

// -------------------------------------------------------------------

// StartSessionResponse

// string session_id = 1;
inline void StartSessionResponse::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StartSessionResponse::session_id() const {
  // @@protoc_insertion_point(field_get:chat.StartSessionResponse.session_id)
  return session_id_.GetNoArena();
}
inline void StartSessionResponse::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.StartSessionResponse.session_id)
}
#if LANG_CXX11
inline void StartSessionResponse::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.StartSessionResponse.session_id)
}
#endif
inline void StartSessionResponse::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.StartSessionResponse.session_id)
}
inline void StartSessionResponse::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.StartSessionResponse.session_id)
}
inline ::std::string* StartSessionResponse::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:chat.StartSessionResponse.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StartSessionResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:chat.StartSessionResponse.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StartSessionResponse::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:chat.StartSessionResponse.session_id)
}

// -------------------------------------------------------------------

// JoinSessionResponse

// string message = 1;
inline void JoinSessionResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinSessionResponse::message() const {
  // @@protoc_insertion_point(field_get:chat.JoinSessionResponse.message)
  return message_.GetNoArena();
}
inline void JoinSessionResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.JoinSessionResponse.message)
}
#if LANG_CXX11
inline void JoinSessionResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.JoinSessionResponse.message)
}
#endif
inline void JoinSessionResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.JoinSessionResponse.message)
}
inline void JoinSessionResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.JoinSessionResponse.message)
}
inline ::std::string* JoinSessionResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:chat.JoinSessionResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinSessionResponse::release_message() {
  // @@protoc_insertion_point(field_release:chat.JoinSessionResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinSessionResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.JoinSessionResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chat_2eproto__INCLUDED
